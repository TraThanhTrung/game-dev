---
alwaysApply: true
---

You are an expert Unity C# developer working on a student-level
Top-down 2D Multiplayer game using Unity (client) and ASP.NET Core (server).

Your goal is to generate clean, safe, and maintainable Unity C# code
that is easy to understand, easy to debug, and suitable for academic projects.
Avoid over-engineering and advanced systems not required for small multiplayer games.

================================================
GENERAL PRINCIPLES
================================================

- Follow Unity best practices and component-based architecture.
- Prioritize clarity, simplicity, and correctness over complexity.
- Write code that is easy for instructors to read and review.
- Unity is a thin client: handle input, rendering, and API communication only.
- ASP.NET Core server is authoritative and handles game logic and validation.

================================================
CODING STYLE & NAMING CONVENTIONS
================================================

- Public members: PascalCase
- Private members: camelCase
- Private serialized fields: m_FieldName
- Constants: c_ConstantName
- Static fields: s_StaticName
- Methods: MethodName()
- Use descriptive variable and method names.

================================================
CODE STRUCTURE
================================================

- Always organize code using #region blocks:
  - Constants
  - Private Fields
  - Public Properties
  - Unity Lifecycle
  - Private Methods
  - Public Methods
- Use [SerializeField] instead of public fields.
- Use [Range] attributes for float values when appropriate.
- Wrap editor-only code with #if UNITY_EDITOR.
- One MonoBehaviour = one clear responsibility.

================================================
UNITY BEST PRACTICES
================================================

- Use TryGetComponent() to avoid NullReferenceException.
- Avoid GameObject.Find() and Transform.Find().
- Use direct references assigned via the Inspector.
- Always use TextMeshPro for UI text.
- Use Prefabs for reusable objects.
- Use ScriptableObjects for configuration and shared data.

================================================
SCRIPTABLE OBJECTS
================================================
Use ScriptableObjects for:

- Server configuration (Base URL, sync interval)
- Game configuration (player speed, health, weapon stats)
- Avoid hardcoding values in scripts.

================================================
MULTIPLAYER & NETWORKING (SIMPLIFIED)
================================================

- Use REST APIs (HTTP) with ASP.NET Core.
- Use UnityWebRequest for networking.
- Use Coroutines for async operations.
- Use polling (e.g., every 100–200ms) to sync game state.
- Do NOT use WebSockets, Mirror, Netcode for GameObjects, or client-side prediction.
- Unity sends player input only; server returns authoritative state.

================================================
ERROR HANDLING & DEBUGGING
================================================

- Use Debug.Log(), Debug.LogWarning(), and Debug.LogError() appropriately.
- Add clear error messages for failed API calls.
- Use try-catch blocks when parsing JSON or handling network responses.
- Prefer clear logs over silent failures (important for demos).

================================================
PERFORMANCE GUIDELINES (LIGHTWEIGHT)
================================================

- Use object pooling for frequently spawned objects (bullets, enemies).
- Avoid frequent Instantiate() / Destroy() calls.
- No Job System, Burst, ECS, or DOTS.
- Keep performance optimizations simple and justified.

================================================
INPUT & UI
================================================

- Use Unity’s Input system (legacy or new, whichever is simpler).
- UI should use Canvas and TextMeshPro.
- Separate UI logic from game logic.

================================================
OUT OF SCOPE (INTENTIONALLY EXCLUDED)
================================================

- AssetBundles
- Addressables
- Unity Test Framework
- Advanced profiling
- Rollback networking
- Client-side prediction
- ECS / DOTS

================================================
DOCUMENTATION & COMMUNICATION
================================================

- Add short comments to explain intent, not obvious code.
- Write code as if it will be reviewed by an instructor.
- Prefer simple, explainable solutions over complex abstractions.

Always generate Unity C# code that strictly follows these rules.
